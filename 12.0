import pandas as pd
import numpy as np
from scipy.optimize import linprog
import json
from datetime import datetime
from typing import List, Dict, Tuple, Optional

# --- CONFIGURACIÓN Y CONSTANTES CIENTÍFICAS (EFSA / HARVARD) ---
EFSA_CONSTANTS = {
    'FIBER_MIN_DAILY': 30,  # gramos
    'MIN_PROTEIN_SEDENTARY': 0.8, # g/kg
    'MAX_PROTEIN_SAFE': 2.5, # g/kg
    'HARVARD_VEG_RATIO': 0.50, # 50% del plato (peso/volumen)
    'HARVARD_PROTEIN_RATIO': 0.25,
    'HARVARD_GRAIN_RATIO': 0.25
}

class UserProfile:
    """
    Gestiona los datos biométricos y calcula los objetivos nutricionales
    basados en ecuaciones estándar (Mifflin-St Jeor).
    """
    def __init__(self, age, weight_kg, height_cm, sex, pal, goal, diet_type):
        self.age = age
        self.weight = weight_kg
        self.height = height_cm
        self.sex = sex.lower()
        self.pal = pal  # Physical Activity Level (1.2 - 2.2)
        self.goal = goal # 'cut', 'bulk', 'maintain'
        self.diet_type = diet_type # 'omni', 'vegan', 'vegetarian'
        
        self.tmb = self._calculate_bmr()
        self.tdee = self.tmb * self.pal
        self.targets = self._calculate_targets()

    def _calculate_bmr(self):
        # Ecuación Mifflin-St Jeor
        s = 5 if self.sex == 'male' else -161
        return (10 * self.weight) + (6.25 * self.height) - (5 * self.age) + s

    def _calculate_targets(self):
        # Ajuste de Calorías
        if self.goal == 'cut':
            cal_target = self.tdee * 0.85 # Déficit moderado (-15%)
            protein_per_kg = 2.0 # Evidencia: Protección muscular en déficit
        elif self.goal == 'bulk':
            cal_target = self.tdee * 1.10 # Superávit leve (+10%)
            protein_per_kg = 1.8 # Rango óptimo hipertrofia
        else:
            cal_target = self.tdee
            protein_per_kg = 1.4 # Mantenimiento activo

        protein_g = self.weight * protein_per_kg
        
        # Grasas: Mínimo 0.8g/kg para salud hormonal (EFSA/ISSN)
        fat_g = max(self.weight * 0.9, (cal_target * 0.25) / 9)
        
        # Carbos: El resto
        carb_cals = cal_target - (protein_g * 4) - (fat_g * 9)
        carb_g = carb_cals / 4

        return {
            "calories": round(cal_target, 0),
            "protein_g": round(protein_g, 1),
            "fat_g": round(fat_g, 1),
            "carbs_g": round(carb_g, 1)
        }

class FoodDatabase:
    """
    Simula una base de datos robusta. En producción, esto conectaría a SQL.
    Incluye datos de compatibilidad y categorías de Harvard.
    """
    def __init__(self):
        self.data = self._mock_database()

    def _mock_database(self):
        # Columnas clave: Flavor_Profile ayuda a la matriz de compatibilidad
        data = [
            # PROTEINS
            {"name": "Chicken Breast", "category": "Protein", "cals": 165, "prot": 31, "carb": 0, "fat": 3.6, "price": 8.5, "min_g": 100, "max_g": 250, "flavor": "savory", "tags": ["omni"]},
            {"name": "Salmon", "category": "Protein", "cals": 208, "prot": 20, "carb": 0, "fat": 13, "price": 18.0, "min_g": 100, "max_g": 200, "flavor": "savory", "tags": ["omni", "fish"]},
            {"name": "Lentils (Cooked)", "category": "Protein", "cals": 116, "prot": 9, "carb": 20, "fat": 0.4, "price": 2.0, "min_g": 100, "max_g": 300, "flavor": "neutral", "tags": ["vegan", "plant_based"]},
            {"name": "Tofu", "category": "Protein", "cals": 76, "prot": 8, "carb": 1.9, "fat": 4.8, "price": 5.0, "min_g": 100, "max_g": 300, "flavor": "neutral", "tags": ["vegan", "plant_based"]},
            
            # VEGETABLES (Harvard 50%)
            {"name": "Broccoli", "category": "Veg", "cals": 34, "prot": 2.8, "carb": 7, "fat": 0.4, "price": 3.0, "min_g": 100, "max_g": 300, "flavor": "neutral", "tags": ["vegan"]},
            {"name": "Spinach", "category": "Veg", "cals": 23, "prot": 2.9, "carb": 3.6, "fat": 0.4, "price": 6.0, "min_g": 50, "max_g": 200, "flavor": "neutral", "tags": ["vegan"]},
            {"name": "Carrot", "category": "Veg", "cals": 41, "prot": 0.9, "carb": 10, "fat": 0.2, "price": 1.5, "min_g": 50, "max_g": 200, "flavor": "sweet_veg", "tags": ["vegan"]},

            # GRAINS / CARBS
            {"name": "Brown Rice", "category": "Grain", "cals": 111, "prot": 2.6, "carb": 23, "fat": 0.9, "price": 2.5, "min_g": 50, "max_g": 250, "flavor": "neutral", "tags": ["vegan"]},
            {"name": "Quinoa", "category": "Grain", "cals": 120, "prot": 4.1, "carb": 21, "fat": 1.9, "price": 6.0, "min_g": 50, "max_g": 250, "flavor": "neutral", "tags": ["vegan"]},
            
            # FATS
            {"name": "Olive Oil", "category": "Fat", "cals": 884, "prot": 0, "carb": 0, "fat": 100, "price": 10.0, "min_g": 5, "max_g": 20, "flavor": "neutral", "tags": ["vegan"]},
            {"name": "Avocado", "category": "Fat", "cals": 160, "prot": 2, "carb": 9, "fat": 15, "price": 9.0, "min_g": 30, "max_g": 100, "flavor": "neutral", "tags": ["vegan"]},

            # FRUIT
            {"name": "Apple", "category": "Fruit", "cals": 52, "prot": 0.3, "carb": 14, "fat": 0.2, "price": 2.0, "min_g": 100, "max_g": 200, "flavor": "sweet", "tags": ["vegan"]},
            {"name": "Pear", "category": "Fruit", "cals": 57, "prot": 0.4, "carb": 15, "fat": 0.1, "price": 2.2, "min_g": 100, "max_g": 200, "flavor": "sweet", "tags": ["vegan"]},
        ]
        return pd.DataFrame(data)

    def get_candidates(self, category, diet_type):
        """Filtra alimentos según categoría y tipo de dieta (Omni/Vegan)"""
        df = self.data[self.data['category'] == category]
        if diet_type == 'vegan':
            df = df[df['tags'].apply(lambda x: 'vegan' in x)]
        elif diet_type == 'vegetarian':
            df = df[df['tags'].apply(lambda x: 'vegan' in x or 'vegetarian' in x)]
        return df

class MealValidator:
    """
    El 'Gatekeeper' de la lógica. Evita combinaciones culinarias desastrosas.
    Usa una Matriz de Adyacencia simplificada.
    """
    def __init__(self):
        # Pares prohibidos (Set de tuplas)
        self.forbidden_combinations = {
            ("fish", "sweet"), # Pescado con frutas dulces
            ("savory", "vanilla"),
            ("dairy", "citrus") # Riesgo de cuajado estomacal/sabor (leche y limón)
        }

    def check_compatibility(self, food_items_df):
        """
        Verifica si los alimentos seleccionados pueden coexistir en el mismo plato.
        """
        flavors = food_items_df['flavor'].tolist()
        tags_lists = food_items_df['tags'].tolist()
        flat_tags = [item for sublist in tags_lists for item in sublist]

        # Ejemplo de regla de negocio
        if "fish" in flat_tags and "sweet" in flavors:
            # Excepción: Melón con jamón (si existiera). Aquí simplificamos.
            return False
        return True

class DietEngine:
    """
    El Cerebro. Usa Scipy Linear Programming para optimizar cantidades.
    """
    def __init__(self, user: UserProfile, db: FoodDatabase):
        self.user = user
        self.db = db
        self.validator = MealValidator()

    def _optimize_quantities(self, selected_foods, target_cals, target_ratios):
        """
        Usa Programación Lineal para encontrar los gramos EXACTOS de cada alimento.
        Minimizar: Costo (o desviación calórica)
        Sujeto a: 
           - Proteína >= target
           - Harvard Ratios (Peso Veg >= Peso Protein + Grain)
           - Min/Max gramaje por alimento (Anti-Absurdity)
        """
        n_foods = len(selected_foods)
        c = selected_foods['price'].values  # Función objetivo: Minimizar precio
        
        # Restricciones de Desigualdad (Ax <= b)
        # Queremos controlar macros aproximados y ratios de Harvard
        
        # Bounds: Límite inferior y superior de gramos (convertido a unidades de 100g para el solver)
        bounds = []
        for _, row in selected_foods.iterrows():
            bounds.append((row['min_g']/100, row['max_g']/100))

        # Ecuación de igualdad (Total Calorías = Target)
        # cals_1 * x1 + cals_2 * x2 ... = target
        A_eq = [selected_foods['cals'].values]
        b_eq = [target_cals]

        # Usamos linprog (Simplex o Interior-Point)
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            return res.x * 100 # Convertir de vuelta a gramos
        else:
            # Fallback simple si la optimización falla (ej. restricciones imposibles)
            return [row['min_g'] for _, row in selected_foods.iterrows()]

    def generate_meal(self, meal_type="lunch"):
        """
        Genera una comida coherente basada en el Plato de Harvard.
        """
        # 1. Selección de Candidatos (Estructura Harvard)
        # Elegimos 1 Proteína, 1-2 Vegetales, 1 Grano, 1 Grasa
        try:
            prot = self.db.get_candidates("Protein", self.user.diet_type).sample(1)
            veg = self.db.get_candidates("Veg", self.user.diet_type).sample(1)
            grain = self.db.get_candidates("Grain", self.user.diet_type).sample(1)
            fat = self.db.get_candidates("Fat", self.user.diet_type).sample(1)
        except ValueError:
            return "Error: Base de datos insuficiente para filtros actuales."

        # Unimos el plato
        plate = pd.concat([prot, veg, grain, fat])

        # 2. Validación de Coherencia (Anti-Absurdity)
        if not self.validator.check_compatibility(plate):
            return self.generate_meal(meal_type) # Reintentar recursivamente

        # 3. Optimización Matemática de Cantidades
        # Asumimos que el almuerzo es el 35% de las calorías diarias
        meal_cals = self.user.targets['calories'] * 0.35
        
        quantities = self._optimize_quantities(plate, meal_cals, None)
        
        plate['grams'] = np.round(quantities, 0)
        plate['total_cals'] = (plate['cals'] * plate['grams']) / 100
        plate['total_price'] = (plate['price'] * plate['grams']) / 1000 # asumiendo precio x kg

        return plate[['name', 'grams', 'total_cals', 'total_price']].to_dict('records')

    def generate_week_plan(self):
        week_plan = {}
        days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        
        for day in days:
            week_plan[day] = {
                "Lunch": self.generate_meal("lunch"),
                "Dinner": self.generate_meal("dinner")
                # Desayuno y Snack se añadirían similarmente
            }
            
        return week_plan

# --- EJECUCIÓN DEL SCRIPT ---

def main():
    print("--- INICIANDO SISTEMA DE OPTIMIZACIÓN NUTRICIONAL ---")
    
    # 1. Crear Usuario
    user = UserProfile(
        age=24, 
        weight_kg=80, 
        height_cm=180, 
        sex='male', 
        pal=1.55, # Moderadamente activo
        goal='cut', 
        diet_type='omni'
    )
    
    print(f"Usuario: {user.sex}, TDEE: {user.tdee:.0f} kcal")
    print(f"Objetivos: {user.targets}")

    # 2. Inicializar DB y Motor
    db = FoodDatabase()
    engine = DietEngine(user, db)

    # 3. Generar Dieta
    weekly_plan = engine.generate_week_plan()

    # 4. Output JSON
    print("\n--- EJEMPLO DE LUNES (Optimizado Matemáticamente) ---")
    print(json.dumps(weekly_plan['Monday'], indent=2))

    # 5. Generar Lista de Compra (Agregación)
    # Aquí iría lógica para sumar todos los gramos de 'Chicken Breast' de la semana
    print("\n--- ESTADO: LISTO PARA EXPORTAR A PDF/APP ---")

if __name__ == "__main__":
    main()
